Génère un module complet nommé Memory (jeu de paires d’emojis) pour une application Expo React Native en TypeScript. Le module doit être autonome et prêt à intégrer dans une app plus large (/src/games/Memory). Fournis tout le code source (TSX/TS), assets (JSON emojis, Lottie placeholder), tests unitaires Jest, et un README minimal pour exécuter localement (expo start). Respecte TypeScript strict, code commenté, bonnes pratiques (useMemo, useCallback), et AsyncStorage pour la persistance.

FONCTIONNALITÉS CLÉS À IMPLEMENTER :

Difficultés & niveaux

3 difficultés : easy, medium, hard.

Chaque difficulté contient une séquence de niveaux numérotés :

easy → niveaux 1 à 100

medium → niveaux 1 à 75

hard → niveaux 1 à 50

Chaque niveau correspond à une configuration (nombre de paires) : par défaut mapper les niveaux comme suit — easy: 8 paires (16 cartes), medium: 10 paires (20 cartes), hard: 15 paires (30 cartes). (Ces mappages doivent être modifiables via constants.ts.)

Déverrouillage séquentiel : le niveau n est accessible seulement si le niveau n-1 a été complété. Les niveaux déjà complétés restent rejouables pour gagner des récompenses supplémentaires.

Les multiples de 5 (ex : level 5,10,15...) doivent être affichés avec une couleur spéciale sur la sélection de niveau et, en cas de victoire sur ces niveaux, le joueur reçoit ×2 bonus (défini dans constants).

Les multiples de 10 déclenchent à la fin de la partie un modal bonus : proposer 6 récompenses aléatoires (ex : 1 XP, 15 XP, 100 XP, 500 XP, 1000 XP, 50 XP) ; l’utilisateur choisit une seule et son XP est incrémenté. Implémente la mécanique (simulée, locale) et persiste XP via AsyncStorage (FUNZONE:xp).

Gameplay mémoire (par niveau)

Pour chaque niveau, génère les cartes à partir d’un pool local d’emojis (assets/data/emojis.json). Duplique + shuffle.

Le joueur retourne deux cartes : match → marquées matched ; sinon → se replient après 700–900ms (animation flip via moti).

Timer démarre au premier flip du niveau. Afficher Temps, Score courant, Meilleur score pour ce niveau/difficulté.

Scoring : (paires_trouvées * 10) - (erreurs * 2) ; bonus +50 pour zéro erreur ; si niveau multiple de 5, appliquer le multiplicateur de bonus. Sauvegarder meilleur score par niveau/difficulty (FUNZONE:memory:bestScore:{difficulty}:{level}).

Système de vies & rechargement

Stocker vies en AsyncStorage (FUNZONE:lives) ; maxLives = 5 (configurable dans constants.ts).

Chaque défaite décrémente 1 vie. Quand une vie est perdue, lancer un timer de 5 minutes (configurable) pour la régénération d’une vie. Gérer plusieurs timers si plusieurs vies manquantes. Persister timestamps nécessaires pour calculer temps restants après redémarrage.

Si lives === 0 et l’utilisateur essaie de lancer un niveau, afficher un modal avec le temps restant pour la prochaine régénération et un bouton Recharger mes vies. Implémente le comportement suivant pour le bouton : simulation d’un mini-jeu ou d’une action asynchrone (ex: promesse résolue après 2s) qui ajoute 1 vie si succès. Respecter la règle : l’utilisateur ne peut pas acheter plus de vies que nécessaire pour atteindre 5. L’UI doit afficher les cœurs (MaterialCommunityIcons) au header.

Permets également l’achat de vies via XP dans la boutique simulée (coûts configurables dans constants.ts, ex: 1 vie = 200 XP, 2 vies = 350 XP, 3 vies = 600 XP, etc.). Valider que l’utilisateur a assez de XP avant achat et empêcher dépassement de 5 vies. Persister XP (FUNZONE:xp).

Sélection de niveau & progression

Fournir un écran LevelSelect montrant la grille de niveaux pour la difficulté choisie (1..N), indiquant : verrouillé/déverrouillé, complété, multiple de 5 (couleur spéciale), multiple de 10 (icône bonus). Les niveaux complétés ont un petit badge de check et affichent le meilleur score.

Cliquer sur un niveau lance le MemoryScreen avec la config correspondante. Si verrouillé, expliquer pourquoi (niveau précédent non complété).

Persistance & clés AsyncStorage

Exemples de clés :

FUNZONE:memory:bestScore:{difficulty}:{level}

FUNZONE:memory:completed:{difficulty} → array des niveaux complétés

FUNZONE:xp → total XP

FUNZONE:lives → { count: number, regenTimestamps: number[] }

FUNZONE:memory:lastGame:{difficulty}:{level} (optionnel)

Fournir un wrapper storage.ts avec getItem<T>, setItem<T>, removeItem et fonctions utilitaires pour marks/completions.

UI/UX & animations

MemoryScreen : Header (titre, difficulté, icônes vies, XP), Timer/Score/Best, grille de cartes responsive (easy cols 4, medium cols 4, hard cols 5), boutons Rejouer, Retour, Suivant/Précédent selon niveau (désactiver prev si level 1, disable next si last level).

Card component avec flip animé (rotation Y) via moti, pulse à la découverte d’une paire, Lottie pour victoire finale (placeholder JSON fourni). Vibration légère sur mauvaise paire (expo-haptics or Vibration).

Accessibilité : accessibilityLabel pour cartes et boutons.

Bonus & modal multiples de 10

Si un niveau complété est multiple de 10, afficher modal de sélection parmi 6 récompenses aléatoires ; l’utilisateur choisit 1. Mettre à jour XP et persist. Modal doit être stylée et accessible.

Tests & qualité

Fournir tests Jest / @testing-library/react-native pour : generateCards, shuffle, logique de matching, storage wrapper (mock AsyncStorage).

TS strict, ESLint/Prettier recommandés (configs dans README).

Architecture & fichiers à créer

/src/games/Memory/index.tsx — écran principal (jeu).

/src/games/Memory/LevelSelect.tsx — sélection des niveaux (1..100 / 1..75 / 1..50).

/src/games/Memory/components/Card.tsx — carte flip animée.

/src/games/Memory/utils.ts — generateCards(difficulty, level), shuffle, règles de mapping niveau→paires.

/src/games/Memory/types.ts — types (Card, Difficulty, LevelState).

/src/games/Memory/constants.ts — MAX_LIVES, REGEN_MS, levelCounts, XP costs, bonusMultipliers, storage keys (modifiable).

/src/games/Memory/storage.ts — wrapper AsyncStorage + helpers markLevelCompleted, isLevelUnlocked, getBestScore, setBestScore, getXP, addXP, getLives, addLife, spendXPForLives.

/src/games/Memory/styles.ts — styles partagés.

/assets/data/emojis.json — pools d’emojis pour easy/medium/hard.

/assets/lottie/success.json — placeholder.

/__tests__/ — tests unitaires.

README.md — instructions d’installation (npm install), packages à installer & rôle, comment intégrer LevelSelect et Memory screen à la navigation, comment lancer tests.

Packages à installer et utilité (à inclure dans README)

@react-native-async-storage/async-storage — persistance locale.

moti — animations (flip, pulse).

lottie-react-native (+ lottie-ios si iOS) — animations victoire.

@expo/vector-icons — icônes MaterialCommunityIcons.

jest + @testing-library/react-native — tests.

expo-haptics (optionnel) — retours haptiques.

expo / react-native — plateforme.

LIVRABLES : fournir le contenu complet de chaque fichier listé ci-dessus (code prêt à coller), assets JSON/Lottie placeholders, tests, et README. Si une partie ne peut être fournie (ex: JSON Lottie exact), indiquer un placeholder et expliquer comment le remplacer. Toutes les constantes importantes (nombre de niveaux, mapping niveau→paires, max lives, regen time, XP costs, bonus multipliers) doivent être modifiables via constants.ts.

Contraintes : tout doit fonctionner hors ligne, pas de dépendances payantes ni d’APIs externes. Persistance locale obligatoire. L’IA/dev doit s’assurer que l’intégration dans une app Expo existante se fasse sans erreurs (expliquer comment ajouter l’écran à React Navigation).